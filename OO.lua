---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by KipKips.
--- DateTime: 2020.3.18 21:47
---

---面向对象编程
--写法一
person={ name="wkp",age=22}
person.eat=function()
    print(person.name.."在吃饭")
end
function person.drink()
    print(person.name.."在喝水")
end
person.eat()
person.drink()

--写法二
person={
    name="wkp",
    age=22,
    eat=function ()
        print(person.name.."在吃饭")
    end
}
person.eat()
print("--------------------------------------------------------")
---上述两种方法在新建对象时,需要全部重新赋值,很不好,所以下面用一种相对简单的方法实现面向对象
person={
    name="wkp",
    age=22,
    eat=function (self)
        print(self.name.."在吃饭")
    end
}
person.eat(person)
print("---------------------------------------------------------")
---上述方法在调用方法时,每次都要传递person参数,很麻烦
--改进
person={
    name="wkp",
    age=22
}
--当方法的声明使用:来声明时,就可以使用self参数,这个参数代表调用方法的对象,即person
function person:eat()
    print(self.age.."岁的"..self.name.."在吃饭")
end
person:eat()

a=person
a.name="wjl"
a:eat()--使用:调用函数不用去传递参数
a.eat(a)--使用.调用函数需要传递参数
print("---------------------------------------------------------")
---添加构造函数
Person={
    name,
    age
}
function Person:eat()
    print(self.age.."岁的"..self.name.."在吃饭")
end
--创建一个表的模板,通过使用模板达到类似构造函数的目的
--使用new方法创建新的表
function Person:new()
    t={}

    --t为元表,若调用属性时,该属性不存在,就在__index指向的表里面去查找
    setmetatable(t,{__index=Person})
    return t
end
--print(Person.name) --nil
p1=Person:new() --创建新的表
p1.name="wjl"
p1.age=23
p1:eat()
print("---------------------------------------------------------")
---对构造函数进行扩展
Person={
    name,
    age
}
function Person:eat()
    print(self.age.."岁的"..self.name.."在吃饭")
end
--创建一个表的模板,通过使用模板达到类似构造函数的目的
--使用new方法创建新的表
function Person:new(o)
    --若o为空,则t={},若o不为空,则t=o
    local t = o or {}  --防止外界访问到t

    --t为元表,若调用属性时,该属性不存在,就在__index指向的表里面去查找
    --1.
    --setmetatable(t,{__index=Person})
    --2.
    setmetatable(t,self)
    self.__index=self
    return t
end

--使用新的构造函数

p1=Person:new(nil)--构造全新的对象,值全为空
print(p1.name,p1.age,p1.weight)

--有参构造函数,可以添加新的属性
p2=Person:new({name="wxy",age=26,weight=100})
print(p2.name,p2.age,p2.weight)
p2:eat()

print("---------------------------------------------------------")
---实现面向对象的类的继承
Person={
    name,
    age
}
function Person:eat()
    print(self.age.."岁的"..self.name.."在吃饭")
end
--创建一个表的模板,通过使用模板达到类似构造函数的目的
--使用new方法创建新的表
function Person:new(o)
    --若o为空,则t={},若o不为空,则t=o
    local t = o or {}  --防止外界访问到t

    --t为元表,若调用属性时,该属性不存在,就在__index指向的表里面去查找
    --1.
    --setmetatable(t,{__index=Person})
    --2.
    setmetatable(t,self)
    self.__index=self
    return t
end

Student=Person:new()
Student.grade=1
Student.class=20

s1=Student:new({grade=4,class=3,weight=100,name="wjz",age=49})
print(s1.name,s1.age,s1.grade,s1.class,s1.weight)
s1:eat()
--s1.eat(s1)
 